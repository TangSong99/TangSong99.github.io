<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UML面向对象方法]]></title>
    <url>%2F2019%2F12%2F02%2FUML%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[UML知识点归纳笔记 面向对象基本概念 什么是分析和设计 分析（analysis）*：强调的是对问题和需求的调查研究，而不是解决方案。 设计（design）*：强调的是满足需求的概念上的解决方案（在软件方面和硬件方面），而不是其实现。 什么是面向对象分析和设计 面向对象分析：强调的是在问题领域内发现和描述对象（或概念） 面向对象设计：强调的是定义软件对象以及它们如何协作以实现需求。 什么是面向对象方法：面向对象方法（Object-Oriented Method）是一种把面向对象的思想应用于软件开发过程中，知道开发活动的系统方法，简称OO方法，是建立在“对象”概念基础上的方法学。 什么是UML统一建模语言（Unified Modeling Language）：是描述、构造和文档化系统制品的可视化语言。 UML介绍：* 用例图*、类图、对象图、构件图、部署图、包图、组合结构图、顺序图、通信图、状态图、活动图、交互概述图、时间图 面向对象方法解决问题的基本思路面向对象方法的解决问题思路是从现实世界中的客观对象（如人和事物）入手，尽量运用人类的自然思维方式来构造软件系统。 强调直接以问题域（现实世界）中的事物为中心来思考问题、认识问题，并根据这些食物的本质特征把它们抽象地表示为系统中的对象，作为系统构成的基本单位。（对象） 用对象的属性表示事物的性质，用对象的操作表示事物的行为。（属性与操作） 对象的属性与操作结合为一体，成为独立不可分的实体，对外屏蔽细节。（封装） 对事物进行分类。把有相同属性和相关操作的对象归为一类，每个对象是它的类的一个实例。（分类） 复杂的对象可以用简单的对象作为其构成部分。（聚合） 通过不同程度上运用抽象原则，可以得到一般的类和特殊的类。特殊类继承一般类的属性与操作，从而简化系统的构造过程及其文档。（继承） 对象之间通过消息进行通讯，以实现对象之间的动态联系。（消息）通过关联表示类（一组对象）之间的静态关系。（关联） 用例图参与者、用例、关联（—&gt;）、包含（-《include》-&gt;强调整体与部分的关系）、扩展（-《extend》-&gt;）、泛化（子—▶️父 继承关系）用例规约（用例文本） 类图 Java大白话讲解设计模式之—UML类图 顺序图（时序图） 是一种强调消息时序的交互图，它主要描述系统中对象和对象之间的交互，它将这些交互建模成消息交换。顺序图显示具体用例（或者是用例的一部分）的详细流程–显示了流程中不同对象之间的调用关系–显示对不同对象的不同调用 角色Actor 对象Object 生命线LifeLine 控制焦点Activation 消息Message（同步消息、异步消息、返回消息） 自关联消息 组合片段 实例： 活动图 业务建模业务建模实践：实例分析•研究对象：某旅店•业务现状：–某旅店可对外开放50个双人间和20个单人间，房间费用视情况按季节调整，但周一到周五提供半价（周末全价）折扣–旅客可以直接入住房间(如果有空房)，也可提前预订；入住和预订都需要登记个人信息–旅客提前预订房间时，需提交一定的订金；入住时间24小时之外的旅客可以取消预订，并退回所有订金，24小时以内则不退还订金–退房时缴纳全部的住宿费用–服务员每月为经理提供房间的预订情况和入住情况的详细信息 GRASP（通用职责分配软件原则）原则全称：General Responsibility Assignment Software Pattern通用职责分配软件原则共9种原则，描述了对象设计和职责分配的基本原则 Information Expert信息专家 把职责分配给具有完成该职责所需要信息的类（单一职责）。 Creator创造者 A是B的聚合/容器/A持有初始化B的数据创建B是会传递给B/A记录B的实例/A频繁使用B时，A创建B。 创造者模式与简单工厂模式、工厂方法模式和抽象工厂模式相对应 Low coupling低耦合 尽可能的减少类之间的连接、依赖： 不需要通信的两对象之间不要进行无所谓的连接 如果A已经连接B，分配A的职责给B不合适就把B的职责分配给A 两个不同模块的内部类之间不能建立连接 High cohesion高内聚 功能性紧密相关的职责应该放在一个类里，并共同完成有限的功能。 Controller控制器 MVC分层架构 优点：增加了可复用和接口可插拔的能力；获得推测用例状态的机会。 Polumorphism多态 一个接口，多个实现。 多态模式在多个GoF设计模式中都有所体现，如适配器模式、命令模式、组合模式、观察者模式、策略模式等等。 Pure Fabrication纯虚构 将一组高内聚的职责分配给一个虚构的或处理方便的“行为”类，它并不是问题域中的概念，而是虚构的事务，以达到支持高内聚、低耦合和重用的目的。 在系统中引入抽象类或接口来提高系统的扩展性也可以认为是纯虚构模式的一种应用。 在很多设计模式中都体现了纯虚构模式，例如适配器模式、策略模式等等。 Indirection间接 分配职责给中间对象以协调组件或服务之间的操作，使得它们不直接耦合。中间对象就是在其他组件之间建立的中介。 在外观模式、代理模式、中介者模式等设计模式中都体现了中介模式 Protected Variations受保护变化 找出预计有变化或不稳定的元素，为其创建稳定的“接口”而分配职责。即：对系统进行抽象化设计，定义系统的抽象层，再通过具体类来进行扩展。如果需要扩展系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，在不修改已有代码的基础上扩展系统的功能。 大多数设计原则和GoF模式都是受保护变化模式的体现。 领域模型建模领域模型与设计类图的区别 领域模型，也叫领域类图：产生于分析阶段，由系统分析师绘制，主要作用是描述业务实体的静态结构，包括业务实体、各个业务实体所具有的业务属性及业务操作、业务实体之间具有的关系。 （实现/设计）类图：产生于设计阶段，由系统设计师绘制，其作用是描述系统的架构结构、指导程序员编码。它包括系统中所有有必要指明的实体类、控制类、界面类及与具体平台有关的所有技术性信息。 软件分析(OOA)与设计(OOD)是编码前的两个阶段，其中分析仅与业务有关，而与技术无关。设计以分析为基础，主要与具体技术有关。 分析阶段由分析师绘制领域类图，设计阶段由设计师绘制实现类图。 领域类图表示系统的静态领域结构，其中的类可能不与最终程序中的类对应；设计类图表示系统的技术架构，是程序员的编码依据，其中的类与系统中的类对应。 领域类图中类的属性与操作仅关注与业务相关的部分，实现类图中的属性与操作要包括最终需要实现的全部方法与操作。 DDD(Domain Driven Design)领域建模: 我们设计一个系统，总是希望它能解决一些问题，这些问题总是会映射到现实问题和概念。 对这些问题进行归纳、分析的过程就是领域建模（这个域，指的就是问题域）。 创建： 寻找概念类 将其绘制为UML类图中的类 添加关联和属性 实例： GoF23种设计模式]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java线程详解]]></title>
    <url>%2F2019%2F11%2F18%2FJava%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[整理了网上大部分java线程相关的知识，并加入一些自己的理解以及代码示例，持续更新java线程的面试笔试题。 线程概述一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。Java中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。一个Java应用总是从main()方法开始运行，mian()方法运行在一个线程内，它被称为主线程。一旦创建一个新的线程，就产生一个新的调用栈。线程总体分两类：用户线程和守候线程。当所有用户线程执行完毕的时候，JVM自动关闭。但是守候线程却不独立于JVM，守候线程一般是由操作系统或者用户自己创建的。 Java线程：创建与启动一、定义线程1、扩展（extends）java.lang.Thread类。此类中有个run()方法，应该注意其用法：public void run()如果该线程是使用独立的Runnable运行对象构造的（@override），则调用该Runnable对象的run方法；否则，该方法不执行任何操作并返回。Thread的子类应该重写该方法（无@override）。 2、实现（implements）java.lang.Runnable接口。void run()使用实现接口Runnable的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象（@override）的run方法。方法run的常规协定是，它可能执行任何所需的操作。 二、实例化线程1、如果是扩展java.lang.Thread类的线程，则直接new即可。2、如果是实现了java.lang.Runnable接口的类，则用Thread的构造方法：Thread(Runnable target)Thread(Runnable target, String name)Thread(ThreadGroup group, Runnable target)Thread(ThreadGroup group, Runnable target, String name)Thread(ThreadGroup group, Runnable target, String name, long stackSize)即： 12Thread thread= new ThreadDemo();Thread runnable= new Thread(new RunnableDemo()); 三、启动线程在线程的Thread对象上调用start()方法，而不是run()或者别的方法。 在调用start()方法之前：线程处于新状态中，新状态指有一个Thread对象，但还没有一个真正的线程。 在调用start()方法之后：发生了一系列复杂的事情启动新的执行线程（具有新的调用栈）；该线程从新状态转移到可运行状态；当该线程获得机会执行时，其目标run()方法将运行（回调机制）。 注意：对Java来说，run()方法没有任何特别之处。像main()方法一样，它只是新线程知道调用的方法名称(和签名)。因此，在Runnable上或者Thread上调用run方法是合法的。但并不启动新的线程。（具体可看run源码） 四、例子RunnableThreadCallable 五、一些常见问题1、线程的名字，一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是mian，非主线程的名字不确定。 2、线程都可以设置名字，也可以获取线程的名字，连主线程也不例外。thread = new Thread(this,threadName);Thread.currentThread().getName() 3、获取当前线程的对象的方法是：Thread.currentThread()； 4、在上面的代码中，只能保证：每个线程都将启动，每个线程都将运行直到完成。一系列线程以某种顺序启动并不意味着将按该顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。 5、当线程目标run()方法结束时该线程完成。 6、一旦线程启动，它就永远不能再重新启动（死线程）。只有一个新的线程可以被启动，并且只能一次。 7、线程的调度是JVM的一部分，在一个CPU的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。(宏观并行，微观串行)众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的。 8、尽管通常采用队列形式，但这是没有保障的。队列形式是指当一个线程完成“一轮”时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，它才能被再次选中。事实上，我们把它称为「可运行池」而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列成一个一个队列的事实。 9、尽管我们无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。（操作系统中的各种调度算法）(以下涉及到操作系统)经典的调度算法：FIFS先来先服务调度算法、SJF短作业优先调度算法、优先级调度算法（高响应比优先调度算法、时间片轮转调度算法、多级反馈队列调度算法） Java线程：线程栈模型与线程的变量要理解线程调度的原理，以及线程执行过程，必须理解线程栈模型。线程栈是指某时刻时内存中线程调度的栈信息，当前调用的方法总是位于栈顶。线程栈的内容是随着程序的运行动态变化的，因此研究线程栈必须选择一个运行的时刻（实际上指代码运行到什么地方)。下面通过一个示例性的代码说明线程（调用）栈的变化过程。这幅图描述在代码执行到两个不同时刻1、2时候，虚拟机线程调用栈示意图。当程序执行到t.start();时候，程序多出一个分支（增加了一个调用栈B），这样，栈A、栈B并行执行。从这里就可以看出方法调用和线程启动的区别了。 Java线程：线程状态的转换一、线程状态死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 二、阻止线程执行对于线程的阻止，考虑一下三个方面，不考虑IO阻塞的情况：睡眠；等待；因为需要一个对象的锁定而被阻塞。 1、睡眠sleep()Thread.sleep(long millis)和Thread.sleep(long millis, int nanos)静态方法强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。当线程睡眠时，它入睡在某个地方，在苏醒之前不会返回到可运行状态。当睡眠时间到期，则返回到可运行状态。线程睡眠的原因：线程执行太快，或者需要强制进入下一轮，因为Java规范不保证合理的轮换。睡眠的位置：为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠。 注意：1、线程睡眠是帮助所有线程获得运行机会的最好方法。2、线程睡眠到期自动苏醒，并返回到可运行状态，不是运行状态。sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行。3、sleep()是静态方法，只能控制当前正在运行的线程。 2、线程的优先级和线程让步yield()线程的让步是通过Thread.yield()来实现的。yield()方法的作用是：暂停当前正在执行的线程对象，并执行其他线程。 要理解yield()，必须了解线程的优先级的概念。线程总是存在优先级，优先级范围在1~10之间。JVM线程调度程序是基于优先级的抢先调度机制。在大多数情况下，当前运行的线程优先级将大于或等于线程池中任何线程的优先级。但这仅仅是大多数情况。 注意：当设计多线程应用程序的时候，一定不要依赖于线程的优先级。因为线程调度优先级操作是没有保障的，只能把线程优先级作用作为一种提高程序效率的方法，但是要保证程序不依赖这种操作。 当线程池中线程都具有相同的优先级，调度程序的JVM实现自由选择它喜欢的线程。这时候调度程序的操作有两种可能：一是选择一个线程运行，直到它阻塞或者运行完成为止。二是时间分片，为池内的每个线程提供均等的运行机会。 设置线程的优先级：线程默认的优先级是创建它的执行线程的优先级。可以通过setPriority(int newPriority)更改线程的优先级。例如： 123Thread t = new MyThread();t.setPriority(8);t.start(); 线程优先级为110之间的正整数，JVM从不会改变一个线程的优先级。然而，110之间的值是没有保证的。一些JVM可能不能识别10个不同的值，而将这些优先级进行每两个或多个合并，变成少于10个的优先级，则两个或多个优先级的线程可能被映射为一个优先级。 线程默认优先级是5，Thread类中有三个常量，定义线程优先级范围：static int MAX_PRIORITY 线程可以具有的最高优先级。static int MIN_PRIORITY 线程可以具有的最低优先级。static int NORM_PRIORITY 分配给线程的默认优先级。 结论：优先级高就先运行，只是获得cpu资源的可能性更大。 3、Thread.yield()方法Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。 yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。 结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。 4、join()方法Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。例如： 123Thread t = new MyThread();t.start();t.join(); 另外，join()方法还有带超时限制的重载版本。例如t.join(5000);则让线程等待5000毫秒，如果超过这个时间，则停止等待，变为可运行状态。线程的加入join()对线程栈导致的结果是线程栈发生了变化，当然这些变化都是瞬时的。 例如：main方法运行thread.join(),这是会让主线程mian等待新的线程thread执行完了，再执行主线程mian下面的代码，thread.join()是然主线程main wait。 小结到目前位置，介绍了线程离开运行状态的3种方法： 调用Thread.sleep()：使当前线程睡眠至少多少毫秒（尽管它可能在指定的时间之前被中断）。 调用Thread.yield()：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。 调用join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。 除了以上三种方式外，还有下面几种特殊情况可能使线程离开运行状态： 线程的run()方法完成。 在对象上调用wait()方法（不是在线程上调用）。 线程不能在对象上获得锁定，它正试图运行该对象的方法代码。 线程调度程序(策略)可以决定将当前运行状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由。 Java线程：线程的同步与锁一、同步问题提出线程的同步是为了防止多个线程访问一个数据对象时，对数据造成的破坏（脏数据、脏读、不可重复读、幻读等）。 二、同步和锁定1、锁的原理Java中每个对象都有一个内置锁当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。 当程序运行到synchronized同步方法或代码块时才该对象锁才起作用。 一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块，直到该锁被释放。 释放锁是指持锁线程退出了synchronized同步方法或代码块。 关于锁和同步，有一下几个要点： 只能同步方法，而不能同步变量和类； 每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？ 不必同步类中所有的方法，类可以同时拥有同步和非同步方法。 如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说：如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。 如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。 线程睡眠时，它所持的任何锁都不会释放。 线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。 同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块。 在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。例如：123456public int fix(int y) &#123; synchronized (this) &#123; x = x - y; &#125; return x;&#125; 当然，同步方法也可以改写为非同步方法，但功能完全一样的，例如： 123public synchronized int getX() &#123; return x++;&#125; 与 12345public int getX() &#123; synchronized (this) &#123; return x; &#125;&#125; 效果是完全一样的。 三、静态方法同步要同步静态方法，需要一个用于整个类对象的锁，这个对象是就是这个类（XXX.class)。 例如： 123public static synchronized int setName(String name)&#123; Xxx.name = name;&#125; 等价于 12345public static int setName(String name)&#123; synchronized(Xxx.class)&#123; Xxx.name = name; &#125;&#125; 即：synchronized主要有两种方法1.1、synchronized块（对象级）： synchronized(this){}1.2、synchronized块（类级别）：类在堆中存在一个class 对象（注意这里的class是小写），所以所谓的类锁，本质上还是对一个对象，在这里也就是class对象进行同步获取。当然体现出来的效果是在类上进行了同步。 synchronized（类名.class）2、 synchronized方法public synchronized String setID(){}(方法锁和私有锁：都属于对象锁) 四、如果线程不能获得锁会怎么样如果线程试图进入同步方法，而其锁已经被占用，则线程在该对象上被阻塞。实质上，线程进入该对象的的一种池中，必须在哪里等待，直到其锁被释放，该线程再次变为可运行或运行为止。 当考虑阻塞时，一定要注意哪个对象正被用于锁定： 调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。 调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上。 静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。 对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将永远不会彼此阻塞。 五、何时需要同步在多个线程同时访问互斥（可交换）数据时，应该同步以保护数据，确保两个线程不会同时修改更改它。 对于非静态字段中可更改的数据，通常使用非静态方法访问。对于静态字段中可更改的数据，通常使用静态方法访问。 六、线程安全类当一个类已经很好的同步以保护它的数据时，这个类就称为“线程安全的”。即使是线程安全类，也应该特别小心，因为操作的线程之间仍然不一定安全。 例如：对线程安全的集合进行判断非空和删除所有元素操作的时候，线程一二都查询非空，但是线程一删除元素后线程二再重复执行是错误的。方法：对所有方法增加一个同步锁，这样，当一个线程访问其中一个同步方法时，其他线程只有等待。 七、线程死锁（涉及操作系统）所谓死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。DeadLockRiskTest 死锁产生的必要条件：（1）互斥（2）不剥夺（3）请求和保持等待（4）循环等待 避免死锁： 加锁顺序（线程按照一定的顺序加锁） 加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁） 死锁检测（LOCK） 总结：避免死锁的方式 让程序每次至多只能获得一个锁。当然，在多线程环境下，这种情况通常并不现实。 设计时考虑清楚锁的顺序，尽量减少嵌在的加锁交互数量。 既然死锁的产生是两个线程无限等待对方持有的锁，那么只要等待时间有个上限不就好了。当然synchronized不具备这个功能，但是我们可以使用Lock类中的tryLock方法去尝试获取锁，这个方法可以指定一个超时时限，在等待超过该时限之后便会返回一个失败信息。我们可以使用ReentrantLock.tryLock()方法，在一个循环中，如果tryLock()返回失败，那么就释放以及获得的锁，并睡眠一小段时间。这样就打破了死锁的闭环。比如：线程T1持有锁L1并且申请获得锁L2，而线程T2持有锁L2并且申请获得锁L3，而线程T3持有锁L3并且申请获得锁L1。此时如果T3申请锁L1失败，那么T3释放锁L3，并进行睡眠，那么T2就可以获得L3了，然后T2执行完之后释放L2, L3，所以T1也可以获得L2了执行完然后释放锁L1, L2，然后T3睡眠醒来，也可以获得L1, L3了。打破了死锁的闭环。 八、线程同步小结 线程同步的目的是为了保护多个线程访问一个资源时对资源的破坏。 线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。 注意：方法锁和私有锁都属于对象锁 对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。（对象锁是在一个类的对象上加的的锁，只有一把，不管有几个方法进行了同步。这些同步方法都共有一把锁，只要一个线程获得了这个对象锁，其他的线程就不能访问该对象的任何一个同步方法。） 对于同步，要时刻清醒在哪个对象上同步，这是关键。 编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。 当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。 死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。 Java线程：线程的交互线程交互的基础知识wait、notify/notifyAll 详解void notify() 唤醒在此对象监视器上等待的单个线程。void notifyAll() 唤醒在此对象监视器上等待的所有线程。void wait() 导致当前的线程等待（前提是先获得锁，即在synchronized同步代码块里使用），直到其他线程调用此对象的 notify()方法或 notifyAll()方法。 三个方法都是Object的本地final方法，无法被重写。由于 wait()、notify/notifyAll() 在synchronized 代码块执行，说明当前线程一定是获取了锁的。当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程让其获得锁。 wait() 需要被try catch包围，以便发生异常中断也可以使wait等待的线程唤醒。 notify 和 notifyAll的区别notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。 12345678910111213141516171819202122public class K &#123; //状态锁 private Object lock; //条件变量 private int now,need; public void produce(int num)&#123; //同步 synchronized (lock)&#123; //当前有的不满足需要，进行等待，直到满足条件 while(now &lt; need)&#123; try &#123; //等待阻塞 lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("我被唤醒了！"); &#125; // 做其他的事情 &#125; &#125;&#125; 显然，只有当前值满足需要值的时候，线程才可以往下执行，所以，必须使用while 循环阻塞。注意，wait() 当被唤醒时候，只是让while循环继续往下走.如果此处用if的话，意味着if继续往下走，会跳出if语句块。 总结： 当等待的事件发生时，需要能够检查notifyAll()通知事件是否已经发生。 通常，解决上面问题的最佳方式是利用某种循环，该循环检查某个条件表达式，只有当正在等待的事情还没有发生的情况下，它才继续等待。 生产者-消费者问题:生产者-消费者问题代码 Java线程：线程的调度-休眠线程休眠的目的是使线程让出CPU的最简单的做法之一，线程休眠时候，会将CPU资源交给其他线程，以便能轮换执行，当休眠一定时间后，线程会苏醒，进入准备状态等待执行。线程休眠的方法是Thread.sleep(long millis)和Thread.sleep(long millis, int nanos)，均为静态方法，哪个线程调用sleep，就休眠哪个线程。 Java线程：线程的调度-优先级与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。 线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5。 在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。 12345678910public class Test &#123; public static void main(String[] args) &#123; Thread t1 = new MyThread1(); Thread t2 = new Thread(new MyRunnable()); t1.setPriority(10); t2.setPriority(1); t2.start(); t1.start(); &#125; &#125; Java线程：线程的调度-让步线程的让步含义就是使当前运行着线程让出CPU资源，但是然给谁不知道，仅仅是让出，线程状态回到可运行状态。 线程的让步使用Thread.yield()方法，yield()为静态方法，功能是暂停当前正在执行的线程对象，并执行其他线程。 详见：Java线程：线程状态的转换——阻止线程执行 Java线程：线程的调度-合并线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时可以使用join方法。 详见：Java线程：线程状态的转换——阻止线程执行joinTest Java线程：线程的调度-守护线程只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。 Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。 User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。daemontest Java线程：线程的同步-同步方法、同步块详见上文：Java线程：线程的同步与锁 注意：在使用synchronized关键字时候，应该尽可能避免在synchronized方法或synchronized块中使用sleep或者yield方法，因为synchronized程序块占有着对象锁，你休息那么其他的线程只能一边等着你醒来执行完了才能执行。不但严重影响效率，也不合逻辑。同样，在同步程序块内调用yeild方法让出CPU资源也没有意义，因为你占用着锁，其他互斥线程还是无法访问同步程序块。当然与同步程序块无关的线程可以获得更多的执行时间。同步块 Java线程：并发协作-死锁详见Java线程：线程的同步与锁——线程死锁 Java线程：volatile关键字Java 语言中的 volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。 解释：Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile 变量的最新值。Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类（例如 “start &lt;=end”）。 出于简易性或可伸缩性的考虑，您可能倾向于使用 volatile 变量而不是锁。当使用 volatile 变量而非锁时，某些习惯用法（idiom）更加易于编码和阅读。此外，volatile 变量不会像锁那样造成线程阻塞，因此也很少造成可伸缩性问题。在某些情况下，如果读操作远远大于写操作，volatile 变量还可以提供优于锁的性能优势。 volatile、synchronizedvolatile 功能，声明了volatile的变量，进行写操作的时候，jvm会向处理器发送一条Lock的前缀指令，会把这个变量所在缓存行的数据写回到系统内存。在多处理器的情况下，保证各个处理器缓存一致性的特点，会实现缓存一致性协议。改变了值的volatile变量，在其他行程被指为失效状态其他线程要使用这个变量，需要重新到驻村里面去取。 synchronized：可重入锁、互斥性、可见性volatile 可以做到原子性，可见性，不能做到复合操作的原子性 比如： volatile int i;i++ 读取i的值，给i加1，把新的值赋值给i，这个i++操作在多线程环境下是无法保证原子性的 synchronized后面锁定的对象，可以是一个类对象，也可以是一个成员变量。第一个线程进来调用monitorener 和monitorexit实现，获取对象的监视器，释放对象监视器后续进程过来，如果monitor还没有释放，那么他获取不到这个对象的monitor，会放到一个对列里面：synthronizedQueue。 等到对象的锁释放了，通知synthronizedQueue出队列，获取那个monitor。 volatile 的限制——只有在状态真正独立于程序内其他内容时才能使用 volatile Java线程：新特征-线程池一、固定大小的线程池//创建一个可重用固定线程数的线程池ExecutorService pool = Executors.newFixedThreadPool(2); 二、单任务线程池//创建一个使用单个 worker线程的 Executor，以无界队列方式来运行该线程。ExecutorService pool = Executors.newSingleThreadExecutor(); 三、可变尺寸的线程池//创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。ExecutorService pool = Executors.newCachedThreadPool(); 四、延迟连接池//创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);//使用延迟执行风格的方法pool.schedule(t4, 10, TimeUnit.MILLISECONDS); 五、单任务延迟连接池//创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。ScheduledExecutorService pool = Executors.newSingleThreadScheduledExecutor(); 六、自定义线程池//创建等待队列BlockingQueue&lt;Runnable&gt; bqueue = new ArrayBlockingQueue&lt;Runnable&gt;(20);//创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。ThreadPoolExecutor pool = new ThreadPoolExecutor(2,3,2,TimeUnit.MILLISECONDS,bqueue); 七、代码参考ThreadPoolDIYThreadPool Java线程：新特征-锁在Java5中，专门提供了锁对象，利用锁可以方便的实现资源的封锁，用来控制对竞争资源并发访问的控制，这些内容主要集中在java.util.concurrent.locks包下面，里面有三个重要的接口Condition、Lock、ReadWriteLock。 Condition：Condition将Object监视器方法（wait、notify和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意Lock实现组合使用，为每个对象提供多个等待 set（wait-set）。 Lock：Lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。 ReadWriteLock：ReadWriteLock维护了一对相关的锁定，一个用于只读操作，另一个用于写入操作。ReentrantReadWriteLock：把它理解成一个数据库的事务锁（拆分成读锁和写锁、写锁之间互斥，读锁不互斥、要获取写锁必须除当前线程外不能存在其他的读锁）。 12ReadWriteLock lock = new ReentrantReadWriteLock(false);sync = fair ? new FairSync() : new NonfairSync(); 注意：lock必须lock.unlock()释放，否则如果受保护的代码抛出异常，锁就可能永远得不到释放。 12345678Lock lock = new ReentrantLock();lock.lock();try &#123; // update object state&#125;finally &#123; lock.unlock(); &#125; 关于ReentrantLock： Java中的ReentrantLock和synchronized两种锁定机制的对比轻松学习java可重入锁(ReentrantLock)的实现原理 在上文中提到了Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，在一定程度上提高了程序的执行效率。Java中读写锁有个接口java.util.concurrent.locks.ReadWriteLock，也有具体的实现 在实际开发中，最好能用读写锁的情况下使用读写锁，而不要用普通锁，以求更好的性能。 锁相关代码 Java线程：新特征-信号量Java的信号量实际上是一个功能完毕的计数器，对控制一定资源的消费与回收有着很重要的意义，信号量常常用于多线程的代码中，并能监控有多少数目的线程等待获取资源，并且通过信号量可以得知可用资源的数目等等，这里总是在强调“数目”二字，但不能指出来有哪些在等待，哪些资源可用。 观点：信号量类如果能返回数目，还能知道哪些对象在等待，哪些资源可使用，就非常完美了，仅仅拿到这些概括性的数字，对精确控制意义不是很大。目前还没想到更好的用法。 信号量代码 Java线程：新特征-阻塞队列阻塞队列是Java5线程新特征中的内容，Java定义了阻塞队列的接口java.util.concurrent.BlockingQueue，阻塞队列的概念是，一个指定长度的队列，如果队列满了，添加新元素的操作会被阻塞等待，直到有空位为止。同样，当队列为空时候，请求队列元素的操作同样会阻塞等待，直到有可用元素为止。有了这样的功能，就为多线程的排队等候的模型实现开辟了便捷通道，非常有用。java.util.concurrent.BlockingQueue继承了java.util.Queue接口，可以参看API文档。 BlockingQueue代码 BlockingQueue核心方法 12345678910111213141516171819202122232425262728293031323334353637public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123; //将给定元素设置到队列中，如果设置成功返回true, 否则返回false。如果是往限定了长度的队列中设置值，推荐使用offer()方法。 boolean add(E e); //将给定的元素设置到队列中，如果设置成功返回true, 否则返回false. e的值不能为空，否则抛出空指针异常。 boolean offer(E e); //将元素设置到队列中，如果队列中没有多余的空间，该方法会一直阻塞，直到队列中有多余的空间。 void put(E e) throws InterruptedException; //将给定元素在给定的时间内设置到队列中，如果设置成功返回true, 否则返回false. boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException; //从队列中获取值，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该方法取得了该值。 E take() throws InterruptedException; //在给定的时间里，从队列中获取值，时间到了直接调用普通的poll方法，为null则直接返回null。 E poll(long timeout, TimeUnit unit) throws InterruptedException; //获取队列中剩余的空间。 int remainingCapacity(); //从队列中移除指定的值。 boolean remove(Object o); //判断队列中是否拥有该值。 public boolean contains(Object o); //将队列中值，全部移除，并发设置到给定的集合中。 int drainTo(Collection&lt;? super E&gt; c); //指定最多数量限制将队列中值，全部移除，并发设置到给定的集合中。 int drainTo(Collection&lt;? super E&gt; c, int maxElements);&#125; 成员详解：ArrayBlockingQueue 基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。 ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。 LinkedBlockingQueue 基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。 DelayQueue DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。使用场景： DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。 PriorityBlockingQueue 基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。 SynchronousQueue 一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。 声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别: 如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略； 但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。 参考链接:https://www.jianshu.com/p/6ba87c7508e4 阻塞队列还有更多实现类，用来满足各种复杂的需求：ArrayBlockingQueue, DelayQueue, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue，具体的API差别也很小。 Java线程：新特征-阻塞栈对于阻塞栈，与阻塞队列相似。不同点在于栈是“后入先出”的结构，每次操作的是栈顶，而队列是“先进先出”的结构，每次操作的是队列头。这里要特别说明一点的是，阻塞栈是Java6的新特征。BlockingDeque代码 Java线程：新特征-条件变量条件变量是Java5线程中很重要的一个概念，顾名思义，条件变量就是表示条件的一种变量。但是必须说明，这里的条件是没有实际含义的，仅仅是个标记而已，并且条件的含义往往通过代码来赋予其含义。这里的条件和普通意义上的条件表达式有着天壤之别。他不是自然语言中的条件概念，而是程序控制的一种手段。 条件变量都实现了java.util.concurrent.locks.Condition接口，条件变量的实例化是通过一个Lock对象上调用newCondition()方法来获取的，这样，条件就和一个锁对象绑定起来了。因此，Java中的条件变量只能和锁配合使用，来控制并发程序访问竞争资源的安全。条件变量的出现是为了更精细控制线程等待与唤醒，在Java5之前，线程的等待与唤醒依靠的是Object对象的wait()和notify()/notifyAll()方法，这样的处理不够精细。而在Java5中，一个锁可以有多个条件，每个条件上可以有多个线程等待，通过调用await()方法，可以让线程在该条件下等待。当调用signalAll()方法，又可以唤醒该条件下的等待的线程。条件变方法非条件变量方法 Java线程：新特征-原子量所谓的原子量即操作变量的操作是“原子的”，该操作不可再分，因此是线程安全的。为何要使用原子变量呢，原因是多个线程对单个变量操作也会引起一些问题。在Java5之前，可以通过volatile、synchronized关键字来解决并发访问的安全问题，但这样太麻烦。Java5之后，专门提供了用来进行单变量多线程并发安全访问的工具包java.util.concurrent.atomic，其中的类也很简单。原子量虽然可以保证单个变量在某一个操作过程的安全，但无法保证你整个代码块，或者整个程序的安全性。因此，通常还应该使用锁等同步机制来控制整个程序的安全性。 atomicTest 原子仅仅是保证变量操作的原子性，但整个程序还需要考虑线程安全的。 Java线程：新特征-障碍器Java5中，添加了障碍器类，为了适应一种新的设计需求，比如一个大型的任务，常常需要分配好多子任务去执行，只有当所有子任务都执行完成时候，才能执行主任务，这时候，就可以选择障碍器了。障碍器是多线程并发控制的一种手段。 CyclicBarrier栅栏类似于闭锁，它能阻塞一组线程直到某个事件的发生。栅栏与闭锁的关键区别在于，所有的线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。CyclicBarrier可以使一定数量的线程反复地在栅栏位置处汇集。当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达栅栏位置，那么栅栏将打开，此时所有的线程都将被释放，而栅栏将被重置以便下次使用。 CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程使用await()方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。CyclicBarrier的另一个构造函数CyclicBarrier(int parties, Runnable barrierAction)，用于线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。调用await方法的线程告诉CyclicBarrier自己已经到达同步点，然后当前线程被阻塞。直到parties个参与线程调用了await方法，CyclicBarrier同样提供带超时时间的await和不带超时时间的await方法。cyclicbarrier代码 面试笔试题（更新中）面试笔试题1]]></content>
  </entry>
  <entry>
    <title><![CDATA[什么是Java内部类?]]></title>
    <url>%2F2019%2F10%2F11%2F%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java内部类详解 内部类（一）概述把类定义在另一个类的内部，该类就被称为内部类。举例：把类Inner定义在类Outer中，类Inner就被称为内部类。 1234class Outer &#123; class Inner &#123; &#125;&#125; (二) 内部类的访问规则 可以直接访问外部类的成员，包括私有 外部类要想访问内部类成员，必须创建对象 (三) 内部类的分类 成员内部类 局部内部类 静态内部类 匿名内部类(1) 成员内部类 成员内部类——就是位于外部类成员位置的类特点：可以使用外部类中所有的成员变量和成员方法（包括private的） A：格式：1234567891011121314151617class Outer &#123; private int age = 20; //成员位置 class Inner &#123; public void show() &#123; System.out.println(age); &#125; &#125;&#125;class Test &#123; public static void main(String[] ages) &#123; //成员内部类是非静态的演示 Outer.Inner oi = new Outer.new Inner(); oi.show(); &#125;&#125; B：创建对象时：1234//成员内部类不是静态的：外部类名.内部类名 对象名 = new 外部类名.new 内部类名();//成员内部类是静态的：外部类名.内部类名 对象名 = new 外部类名.内部类名(); C：成员内部类常见修饰符：1.private如果我们的内部类不想轻易被任何人访问，可以选择使用private修饰内部类，这样我们就无法通过创建对象的方法来访问，想要访问只需要在外部类中定义一个public修饰的方法，间接调用。这样做的好处就是，我们可以在这个public方法中增加一些判断语句，起到数据安全的作用。 12345678910111213141516class Outer &#123; private class Inner &#123; public void show() &#123; System.out.println(“密码备份文件”); &#125; &#125; public void method() &#123; if(你是管理员)&#123; Inner i = new Inner(); i.show(); &#125;else &#123; System.out.println(“你没有权限访问”); &#125; &#125;&#125; 下面我们给出一个更加规范的写法 1234567891011121314151617class Outer &#123; private class Inner &#123; public void show() &#123; System.out.println(“密码备份文件”); &#125; &#125; //使用getXxx()获取成员内部类，可以增加校验语句（文中省略） public void getInner() &#123; return new Inner(); &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Outer.Inner inner = outer.getInner(); inner.show(); &#125;&#125; 2.static这种被 static 所修饰的内部类，按位置分，属于成员内部类，但也可以称作静态内部类，也常叫做嵌套内部类。具体内容我们在下面详细讲解。 D：成员内部类经典题(填空)请在三个println 后括号中填空使得输出25,20,18 123456789101112class Outer &#123; public int age = 18; class Inner &#123; public int age = 20; public viod showAge() &#123; int age = 25; System.out.println(age);//空1 System.out.println(this.age);//空2 System.out.println(Outer.this.age);//空3 &#125; &#125;&#125; (2) 局部内部类 局部内部类——就是定义在一个方法或者一个作用域里面的类特点：主要是作用域发生了变化，只能在自身所在方法和属性中被使用 A：格式：123456class Outer &#123; public void method()&#123; class Inner &#123; &#125; &#125;&#125; B：访问时：1234567891011121314151617//在局部位置，可以创建内部类对象，通过对象调用和内部类方法class Outer &#123; private int age = 20; public void method() &#123; final int age2 = 30; class Inner &#123; public void show() &#123; System.out.println(age); //从内部类中访问方法内变量age2，需要将变量声明为最终类型。 System.out.println(age2); &#125; &#125; Inner i = new Inner(); i.show(); &#125;&#125; C: 为什么局部内部类访问局部变量必须加final修饰呢？因为局部变量是随着方法的调用而调用，使用完毕就消失，而堆内存的数据并不会立即消失。 所以，堆内存还是用该变量，而该变量已经没有了。为了让该值还存在，就加final修饰。 原因是，当我们使用final修饰变量后，堆内存直接存储的是值 ，而不是变量名。（即上例 age2 的位置存储着常量30 而不是 age2 这个变量名） (3) 静态内部类 我们所知道static是不能用来修饰类的,但是成员内部类可以看做外部类中的一个成员,所以可以用static修饰,这种用static修饰的内部类我们称作静态内部类,也称作嵌套内部类.特点：不能使用外部类的非static成员变量和成员方法 解释：非静态内部类编译后会默认的保存一个指向外部类的引用，而静态类却没有。 简单理解：即使没有外部类对象，也可以创建静态内部类对象，而外部类的非static成员必须依赖于对象的调用，静态成员则可以直接使用类调用，不必依赖于外部类的对象，所以静态内部类只能访问静态的外部属性和方法。1234567891011121314151617181920class Outter &#123; int age = 10; static age2 = 20; public Outter() &#123; &#125; static class Inner &#123; public method() &#123; System.out.println(age);//错误 System.out.println(age2);//正确 &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Outter.Inner inner = new Outter.Inner(); inner.method(); &#125;&#125; (4) 匿名内部类 一个没有名字的类，是内部类的简化写法 A 格式：123new 类名或者接口名() &#123; 重写方法();&#125; 本质：其实是继承该类或者实现接口的子类匿名对象这也就是下例中，可以直接使用 new Inner() {}.show(); 的原因 == 子类对象.show(); 1234567891011121314151617181920interface Inter &#123; public abstract void show();&#125;class Outer &#123; public void method()&#123; new Inner() &#123; public void show() &#123; System.out.println("HelloWorld"); &#125; &#125;.show(); &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Outer o = new Outer(); o.method(); &#125;&#125; 如果匿名内部类中有多个方法又该如何调用呢？ 12345Inter i = new Inner() &#123; //多态，因为new Inner()&#123;&#125;代表的是接口的子类对象 public void show() &#123; System.out.println("HelloWorld"); &#125;&#125;; B：匿名内部类在开发中的使用我们在开发的时候，会看到抽象类，或者接口作为参数。而这个时候，实际需要的是一个子类对象。如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化 参考：https://www.cnblogs.com/ideal-20/p/11050181.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[PC端查看连接过的WiFi密码]]></title>
    <url>%2F2019%2F10%2F01%2FPC%E7%AB%AF%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%9A%84WiFi%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[只需10秒，无需工具，PC端查看连接过的WiFi密码 Win+R 输入cmd 粘贴下面语句 1for /f "skip=9 tokens=1,2 delims=:" %i in ('netsh wlan show profiles') do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear 结果如图]]></content>
  </entry>
  <entry>
    <title><![CDATA[智慧树刷课]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%99%BA%E6%85%A7%E6%A0%91%E5%88%B7%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[智慧树刷课教程 演示因为代刷网课赚钱会被抓，只好免费分享出来了呜呜呜。智慧树网课刷课（超星尔雅没试过） 代码123456789101112131415161718192021222324252627282930313233343536373839404142(function () &#123; const MAX_DELAY = 60 // 切课时的最大延迟，单位：秒 const sleep = (time) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, time)) const start = async function () &#123; console.log('智慧树助手已启动，唐宋丶https://tangsong99.github.io') while (true) &#123; console.log('正在检查') const delay = Math.floor(Math.random() * MAX_DELAY * 1000) + 1000 if (!/1\.5/.test($('.speedBox').attr('style'))) &#123; console.log('提升到1.5倍速') $('.speedTab15').click() &#125; if (!/liuchang/.test($('.definiBox').attr('style'))) &#123; console.log('更改画质') $('.line1bq').click() &#125; if ($('.volumeBox').find('.passVolume').width() != 0) &#123; console.log('静音') $('.volumeIcon').click() &#125; if ($('.playButton').length &gt; 0) &#123; console.log('点击播放') $('.playButton').click() &#125; if ($('.popbtn_cancel')[0]) &#123; console.log('发现弹题，将在' + delay / 1000 + ' 秒后点击关闭') await sleep(delay / 2) const iframe = document.getElementById('tmDialog_iframe').contentWindow iframe.document.querySelector('.answerOption label').click() await sleep(delay / 2) $('.popbtn_cancel').click() &#125; if ($('.current_play').find('.progressbar').width() == $('.current_play').find('.progressbar_box').width()) &#123; console.log('本节完成，' + delay / 1000 + ' 秒后将切到下一课') await sleep(delay) $('.current_play').nextAll('.video')[0].click() &#125; await sleep(1000) &#125; &#125; start()&#125;()) 最后网课一般都有警告什么刷课会抓，但是我刷了好几个都没啥事，如有被封，后果自负。附：网课答案我是从微省app查的，微信公众号的答案分享平台生命周期太短了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Maven入门教程（IDEA版）]]></title>
    <url>%2F2019%2F09%2F15%2FMaven%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88IDEA%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文主要介绍Maven Web的入门配置教程以及两套web常用依赖分享 File-&gt;new Project如图，Next 项目命名GroupId（公司名）eg：cn.jmuArtifictId（项目名）eg：hellomaven如图，Next 选择Maven选择自己安装的apache-maven，初次默认会自动下载（下文）或者文末有传送门 存放地址如图，Finish 项目生成盗张图，初次装配看这里↓效果图 补齐文件夹手动补齐附：MVC项目目录结构 配置pom.xml配置依赖和其他设置，文末提供两套web的pom.xml模板 配置Tomcat如图，最后点击ok Run/Debug上结果： 传送门pom.xml依赖查找：MavenRrpositoryhelloMaven项目GitHub（附两种pom.xml）：https://github.com/TangSong99/Maven-test]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F09%2F14%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文介绍了Mardown的基本语法 1.设置分级标题1234567# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 一级标题二级标题三级标题四级标题五级标题六级标题 2.加粗、斜体、下划线、删除线12唐宋丶 **唐宋丶** *唐宋丶* &lt;u&gt;唐宋丶&lt;/u&gt; ~~唐宋丶~~ ***~~&lt;u&gt;唐宋丶&lt;/u&gt;~~*** 唐宋丶 唐宋丶 唐宋丶 唐宋丶 唐宋丶唐宋丶 3.分割线1*** 4.引用文本123&gt; 如今漂泊赋沉沦， 剑光不及饮者名， 落魄江湖载酒行 . 如今漂泊赋沉沦， 剑光不及饮者名， 落魄江湖载酒行 . 5.符号列表、数字列表1234561. 数字列表12. 数字列表23. 数字列表3* 符号列表1* 符号列表2* 符号列表3 数字列表1 数字列表2 数字列表3 符号列表1 符号列表2 符号列表3 6.待办事项（多选框）1234待办√* [x] 待办事项一* [ ] 待办事项二* [ ] 待办事项三 待办√ 待办事项一 待办事项二 待办事项三 7.插入链接1[唐宋丶的博客链接 戳这里戳这里&gt;_&lt;](https://tangsong99.github.io/) 唐宋丶的博客链接 戳这里戳这里&gt;_&lt; 8.插入图片1![image](http://i2.tiimg.com/669018/1f01b59ed75569f7.jpg) 1![bj](1.png) 网络图片 本地图片格式支持 jpg、png 和 gif针对插入的本地图片可以控制图片大小，在拖拽、拷贝或者点击插入本地图片之后，直接在图片名称后面（无需空格）添加以下语法均可以按照以下要求控制图片大小： @w=300 @h=150 @w=200h=100 @h=100w=200 目前Hexo不支持图片显示问题解决：hexo引用本地图片无法显示 9.插入表格12345| 课程表 | 工作日 | 周六 | 周日 || --- | --- | --- | --- || 上午 | 划水 | 划水 | 划水 || 下午 | 划水 | 划水 | 划水 || 晚上 | 划水 | 划水 | 划水| 课程表 工作日 周六 周日 上午 划水 划水 划水 下午 划水 划水 划水 晚上 划水 划水 划水 10.插入图表12345678910111213141516* 饼状图```chart,Budget,Income,Expenses,DebtJune,5000,8000,4000,6000July,3000,1000,4000,3000Aug,5000,7000,6000,3000Sep,7000,2000,3000,1000Oct,6000,5000,4000,2000Nov,4000,3000,5000,type: pietitle: Monthly Revenuex.title: Amounty.title: Monthy.suffix: $(```) 饼状图、折线图、柱状图和条形图，只需将 type 改为对应的pie、line、column 和 bar。 饼状图 折线图 柱状图 条形图目前Hexo不支持此类，表格解决：在 Hexo 中插入 ECharts 动态图表 11.插入行内代码或代码块123456789101112```python#!/usr/bin/pythonimport reline = "Cats are smarter than dogs"matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)if matchObj: print "matchObj.group() : ", matchObj.group() print "matchObj.group(1) : ", matchObj.group(1) print "matchObj.group(2) : ", matchObj.group(2)else: print "No match!!"(```) 12345678910#!/usr/bin/pythonimport reline = "Cats are smarter than dogs"matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)if matchObj: print "matchObj.group() : ", matchObj.group() print "matchObj.group(1) : ", matchObj.group(1) print "matchObj.group(2) : ", matchObj.group(2)else: print "No match!!" 12.插入数学公式123```mathe^&#123;i\pi&#125; + 1 = 0(```) 目前Hexo不支持此类，数学公式渲染解决：渲染 MathJax 数学公式更多数学公式的输入可以参考：Supported Functions 13.插入流程图12345678```mermaidgraph TDA[模块A] --&gt;|A1| B(模块B)B --&gt; C&#123;判断条件C&#125;C --&gt;|条件C1| D[模块D]C --&gt;|条件C2| E[模块E]C --&gt;|条件C3| F[模块F](```) Hexo目前不支持 14.插入时序图12345```mermaidsequenceDiagramA-&gt;&gt;B: 是否已收到消息？B--&gt;&gt;A: 已收到消息(```) Hexo目前不支持 15.插入甘特图12345678910```mermaidgantttitle 甘特图dateFormat YYYY-MM-DDsection 项目A任务1 :a1, 2018-06-06, 30d任务2 :after a1 , 20dsection 项目B任务3 :2018-06-12 , 12d(```) Hexo目前不支持 16.设置目录、快捷键1[TOC] [TOC]（由于第一个分级标题出现一级标题所以显示失败）Hexo目前不支持 写在最后Markdown语法编辑器有很多，大多人首推Typora，我平时做笔记的印象笔记也支持就直接用了，可以实时查看很方便。 新建Markdown笔记 Ctrl+Alt+D 粗体 Ctrl+B 斜体 Ctrl+I 删除线 Ctrl+T 下划线 Ctrl+U 分隔线 Ctrl+Shift+- 编号列表 Ctrl+Shift+O 项目符号列表 Ctrl+Shift+W 插入待办事项 Ctrl+Shift+C 代码块 Ctrl+Shift+L 插入日期和时间 Alt+Shift+D 撤销 Ctrl+Z 在笔记内搜索 Ctrl+F]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
