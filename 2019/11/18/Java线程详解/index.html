<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: './public/search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="整理了网上大部分java线程相关的知识，并加入一些自己的理解以及代码示例，持续更新java线程的面试笔试题。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java线程详解">
<meta property="og:url" content="http://TangSong99.github.io/2019/11/18/Java线程详解/index.html">
<meta property="og:site_name" content="唐宋丶">
<meta property="og:description" content="整理了网上大部分java线程相关的知识，并加入一些自己的理解以及代码示例，持续更新java线程的面试笔试题。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://tangsong99.github.io/2019/11/18/Java线程详解/0.png">
<meta property="og:image" content="http://tangsong99.github.io/2019/11/18/Java线程详解/1.png">
<meta property="og:image" content="http://tangsong99.github.io/2019/11/18/Java线程详解/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png">
<meta property="og:image" content="http://tangsong99.github.io/2019/11/18/Java线程详解/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
<meta property="og:updated_time" content="2019-11-19T09:27:34.258Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java线程详解">
<meta name="twitter:description" content="整理了网上大部分java线程相关的知识，并加入一些自己的理解以及代码示例，持续更新java线程的面试笔试题。">
<meta name="twitter:image" content="http://tangsong99.github.io/2019/11/18/Java线程详解/0.png">
  <link rel="canonical" href="http://TangSong99.github.io/2019/11/18/Java线程详解/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Java线程详解 | 唐宋丶</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">唐宋丶</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">世中逢尔.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">0</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">0</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">7</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-wrapper">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    

  <a href="https://github.com/TangSong99" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://TangSong99.github.io/2019/11/18/Java线程详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="唐宋丶">
      <meta itemprop="description" content="在努力在生活在前进.">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="唐宋丶">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Java线程详解

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-11-18 23:54:43" itemprop="dateCreated datePublished" datetime="2019-11-18T23:54:43+08:00">2019-11-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-19 17:27:34" itemprop="dateModified" datetime="2019-11-19T17:27:34+08:00">2019-11-19</time>
              </span>
            
          

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>整理了网上大部分java线程相关的知识，并加入一些自己的理解以及代码示例，持续更新java线程的面试笔试题。<br><img src="//TangSong99.github.io/2019/11/18/Java线程详解/0.png" alt></p>
<a id="more"></a>
<h4 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h4><p>一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。<br>Java中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。<br>一个Java应用总是从main()方法开始运行，mian()方法运行在一个线程内，它被称为主线程。<br>一旦创建一个新的线程，就产生一个新的调用栈。<br>线程总体分两类：<strong>用户线程</strong>和<strong>守候线程</strong>。<br>当所有用户线程执行完毕的时候，JVM自动关闭。但是守候线程却不独立于JVM，守候线程一般是由操作系统或者用户自己创建的。</p>
<hr>
<h4 id="Java线程：创建与启动"><a href="#Java线程：创建与启动" class="headerlink" title="Java线程：创建与启动"></a>Java线程：创建与启动</h4><h5 id="一、定义线程"><a href="#一、定义线程" class="headerlink" title="一、定义线程"></a>一、定义线程</h5><p><strong>1、扩展（extends）java.lang.Thread类。</strong><br>此类中有个run()方法，应该注意其用法：<br>public void run()<br>如果该线程是使用独立的Runnable运行对象构造的（@override），则调用该Runnable对象的run方法；否则，该方法不执行任何操作并返回。<br>Thread的子类应该重写该方法（无@override）。</p>
<p><strong>2、实现（implements）java.lang.Runnable接口。</strong><br>void run()<br>使用实现接口Runnable的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象（@override）的run方法。<br>方法run的常规协定是，它可能执行任何所需的操作。</p>
<h5 id="二、实例化线程"><a href="#二、实例化线程" class="headerlink" title="二、实例化线程"></a>二、实例化线程</h5><p>1、如果是扩展java.lang.Thread类的线程，则直接new即可。<br>2、如果是实现了java.lang.Runnable接口的类，则用Thread的构造方法：<br><code>Thread(Runnable target)</code><br><code>Thread(Runnable target, String name)</code><br><code>Thread(ThreadGroup group, Runnable target)</code><br><code>Thread(ThreadGroup group, Runnable target, String name)</code><br><code>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</code><br>即：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span> <span class="keyword">thread</span>= <span class="keyword">new</span> ThreadDemo()<span class="comment">;</span></span><br><span class="line"><span class="keyword">Thread</span> runnable= <span class="keyword">new</span> <span class="keyword">Thread</span>(<span class="keyword">new</span> RunnableDemo())<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h5 id="三、启动线程"><a href="#三、启动线程" class="headerlink" title="三、启动线程"></a>三、启动线程</h5><p>在线程的Thread对象上调用start()方法，而不是run()或者别的方法。</p>
<p>在调用start()方法之前：线程处于新状态中，新状态指有一个Thread对象，但还没有一个真正的线程。</p>
<p>在调用start()方法之后：发生了一系列复杂的事情<br>启动新的执行线程（具有新的调用栈）；<br>该线程从新状态转移到可运行状态；<br>当该线程获得机会执行时，其目标run()方法将运行（回调机制）。</p>
<p>注意：对Java来说，run()方法没有任何特别之处。像main()方法一样，它只是新线程知道调用的方法名称(和签名)。因此，在Runnable上或者Thread上调用run方法是合法的。但并不启动新的线程。（具体可看run源码）</p>
<h5 id="四、例子"><a href="#四、例子" class="headerlink" title="四、例子"></a>四、例子</h5><p><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/runnable" target="_blank" rel="noopener">Runnable</a><br><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/thread" target="_blank" rel="noopener">Thread</a><br><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/callable" target="_blank" rel="noopener">Callable</a></p>
<h5 id="五、一些常见问题"><a href="#五、一些常见问题" class="headerlink" title="五、一些常见问题"></a>五、一些常见问题</h5><p>1、线程的名字，一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是mian，非主线程的名字不确定。</p>
<p>2、线程都可以设置名字，也可以获取线程的名字，连主线程也不例外。<br>thread = new Thread(this,threadName);<br>Thread.currentThread().getName()</p>
<p>3、获取当前线程的对象的方法是：Thread.currentThread()；</p>
<p>4、在上面的代码中，只能保证：每个线程都将启动，每个线程都将运行直到完成。<strong>一系列线程以某种顺序启动并不意味着将按该顺序执行</strong>。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。</p>
<p>5、当线程目标run()方法结束时该线程完成。</p>
<p>6、一旦线程启动，它就永远不能再重新启动（死线程）。只有一个新的线程可以被启动，并且只能一次。</p>
<p>7、线程的调度是JVM的一部分，在一个CPU的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。(<strong>宏观并行，微观串行</strong>)<br>众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的。</p>
<p>8、尽管通常采用队列形式，但这是没有保障的。队列形式是指当一个线程完成“一轮”时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，它才能被再次选中。事实上，我们把它称为「<strong>可运行池</strong>」而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列成一个一个队列的事实。</p>
<p>9、尽管我们无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。（操作系统中的各种调度算法）<br>(以下涉及到操作系统)经典的调度算法：<br>FIFS先来先服务调度算法、SJF短作业优先调度算法、优先级调度算法（高响应比优先调度算法、时间片轮转调度算法、多级反馈队列调度算法）</p>
<hr>
<h4 id="Java线程：线程栈模型与线程的变量"><a href="#Java线程：线程栈模型与线程的变量" class="headerlink" title="Java线程：线程栈模型与线程的变量"></a>Java线程：线程栈模型与线程的变量</h4><p>要理解线程调度的原理，以及线程执行过程，必须理解线程栈模型。<br>线程栈是指某时刻时内存中线程调度的栈信息，当前调用的方法总是位于栈顶。线程栈的内容是随着程序的运行动态变化的，因此研究线程栈必须选择一个运行的时刻（实际上指代码运行到什么地方)。<br>下面通过一个示例性的代码说明线程（调用）栈的变化过程。<br><img src="//TangSong99.github.io/2019/11/18/Java线程详解/1.png" alt><br>这幅图描述在代码执行到两个不同时刻1、2时候，虚拟机线程调用栈示意图。<br>当程序执行到t.start();时候，程序多出一个分支（增加了一个调用栈B），这样，栈A、栈B并行执行。<br>从这里就可以看出方法调用和线程启动的区别了。</p>
<hr>
<h4 id="Java线程：线程状态的转换"><a href="#Java线程：线程状态的转换" class="headerlink" title="Java线程：线程状态的转换"></a>Java线程：线程状态的转换</h4><h5 id="一、线程状态"><a href="#一、线程状态" class="headerlink" title="一、线程状态"></a>一、线程状态</h5><p><img src="//TangSong99.github.io/2019/11/18/Java线程详解/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt><br><img src="//TangSong99.github.io/2019/11/18/Java线程详解/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt><br>死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p>
<h5 id="二、阻止线程执行"><a href="#二、阻止线程执行" class="headerlink" title="二、阻止线程执行"></a>二、阻止线程执行</h5><p>对于线程的阻止，考虑一下三个方面，不考虑IO阻塞的情况：<br>睡眠；<br>等待；<br>因为需要一个对象的锁定而被阻塞。</p>
<h6 id="1、睡眠sleep"><a href="#1、睡眠sleep" class="headerlink" title="1、睡眠sleep()"></a>1、睡眠sleep()</h6><p>Thread.sleep(long millis)和Thread.sleep(long millis, int nanos)静态方法强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。当线程睡眠时，它入睡在某个地方，在苏醒之前不会返回到可运行状态。当睡眠时间到期，则返回到可运行状态。<br>线程睡眠的原因：线程执行太快，或者需要强制进入下一轮，因为Java规范不保证合理的轮换。<br>睡眠的位置：为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠。</p>
<p><strong>注意：</strong><br>1、线程睡眠是帮助所有线程获得运行机会的最好方法。<br>2、<strong>线程睡眠到期自动苏醒，并返回到可运行状态，不是运行状态</strong>。sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行。<br>3、sleep()是静态方法，只能控制当前正在运行的线程。</p>
<h6 id="2、线程的优先级和线程让步yield"><a href="#2、线程的优先级和线程让步yield" class="headerlink" title="2、线程的优先级和线程让步yield()"></a>2、线程的优先级和线程让步yield()</h6><p>线程的让步是通过Thread.yield()来实现的。yield()方法的作用是：暂停当前正在执行的线程对象，并执行其他线程。</p>
<p>要理解yield()，必须了解线程的优先级的概念。线程总是存在优先级，优先级范围在1~10之间。JVM线程调度程序是基于优先级的抢先调度机制。在大多数情况下，当前运行的线程优先级将大于或等于线程池中任何线程的优先级。但这仅仅是大多数情况。</p>
<p>注意：当设计多线程应用程序的时候，一定不要依赖于线程的优先级。因为线程调度优先级操作是没有保障的，只能把线程优先级作用作为一种提高程序效率的方法，但是要保证程序不依赖这种操作。</p>
<p>当线程池中线程都具有相同的优先级，调度程序的JVM实现自由选择它喜欢的线程。这时候调度程序的操作有两种可能：一是选择一个线程运行，直到它阻塞或者运行完成为止。二是时间分片，为池内的每个线程提供均等的运行机会。</p>
<p>设置线程的优先级：线程默认的优先级是创建它的执行线程的优先级。可以通过<code>setPriority(int newPriority)</code>更改线程的优先级。例如：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t = new MyThread()<span class="comment">;</span></span><br><span class="line">t.setPriority(<span class="number">8</span>)<span class="comment">;</span></span><br><span class="line">t.start()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>线程优先级为1<del>10之间的正整数，JVM从不会改变一个线程的优先级。然而，1</del>10之间的值是没有保证的。一些JVM可能不能识别10个不同的值，而将这些优先级进行每两个或多个合并，变成少于10个的优先级，则两个或多个优先级的线程可能被映射为一个优先级。</p>
<p>线程默认优先级是5，Thread类中有三个常量，定义线程优先级范围：<br><code>static int MAX_PRIORITY</code><br>          线程可以具有的最高优先级。<br><code>static int MIN_PRIORITY</code><br>          线程可以具有的最低优先级。<br><code>static int NORM_PRIORITY</code><br>          分配给线程的默认优先级。</p>
<p><strong>结论：优先级高就先运行，只是获得cpu资源的可能性更大</strong>。</p>
<h6 id="3、Thread-yield-方法"><a href="#3、Thread-yield-方法" class="headerlink" title="3、Thread.yield()方法"></a>3、Thread.yield()方法</h6><p>Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。</p>
<p><strong>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会</strong>。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p>
<p><strong>结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果</strong>。</p>
<h6 id="4、join-方法"><a href="#4、join-方法" class="headerlink" title="4、join()方法"></a>4、join()方法</h6><p>Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。例如：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t = new MyThread()<span class="comment">;</span></span><br><span class="line">t.start()<span class="comment">;</span></span><br><span class="line">t.join()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>另外，join()方法还有带超时限制的重载版本。例如t.join(5000);则让线程等待5000毫秒，如果超过这个时间，则停止等待，变为可运行状态。<br>线程的加入join()对线程栈导致的结果是线程栈发生了变化，当然这些变化都是瞬时的。</p>
<p>例如：<br><strong>main方法运行thread.join(),这是会让主线程mian等待新的线程thread执行完了，再执行主线程mian下面的代码，thread.join()是然主线程main wait</strong>。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>到目前位置，介绍了线程离开运行状态的3种方法：</p>
<ol>
<li>调用Thread.sleep()：使当前线程睡眠至少多少毫秒（尽管它可能在指定的时间之前被中断）。</li>
<li>调用Thread.yield()：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。</li>
<li>调用join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。</li>
</ol>
<p>除了以上三种方式外，还有下面几种特殊情况可能使线程离开运行状态：</p>
<ol>
<li>线程的run()方法完成。</li>
<li>在对象上调用wait()方法（不是在线程上调用）。</li>
<li>线程不能在对象上获得锁定，它正试图运行该对象的方法代码。</li>
<li>线程调度程序(策略)可以决定将当前运行状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由。</li>
</ol>
<hr>
<h4 id="Java线程：线程的同步与锁"><a href="#Java线程：线程的同步与锁" class="headerlink" title="Java线程：线程的同步与锁"></a>Java线程：线程的同步与锁</h4><h5 id="一、同步问题提出"><a href="#一、同步问题提出" class="headerlink" title="一、同步问题提出"></a>一、同步问题提出</h5><p>线程的同步是为了防止多个线程访问一个数据对象时，对数据造成的破坏（脏数据、脏读、不可重复读、幻读等）。</p>
<h5 id="二、同步和锁定"><a href="#二、同步和锁定" class="headerlink" title="二、同步和锁定"></a>二、同步和锁定</h5><p><strong>1、锁的原理</strong><br>Java中每个对象都有一个内置锁<br>当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。</p>
<p>当程序运行到synchronized同步方法或代码块时才该对象锁才起作用。</p>
<p>一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块，直到该锁被释放。</p>
<p>释放锁是指持锁线程退出了synchronized同步方法或代码块。</p>
<p>关于锁和同步，有一下几个要点：</p>
<ol>
<li>只能同步方法，而不能同步变量和类；</li>
<li>每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？</li>
<li>不必同步类中所有的方法，类可以同时拥有同步和非同步方法。</li>
<li>如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说：<strong>如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。</strong></li>
<li>如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。</li>
<li><strong>线程睡眠时，它所持的任何锁都不会释放。</strong></li>
<li>线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。</li>
<li>同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块。</li>
<li>在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。例如：<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        x = x - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>当然，同步方法也可以改写为非同步方法，但功能完全一样的，例如：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果是完全一样的。</p>
<h5 id="三、静态方法同步"><a href="#三、静态方法同步" class="headerlink" title="三、静态方法同步"></a>三、静态方法同步</h5><p>要同步静态方法，需要一个用于整个类对象的锁，这个对象是就是这个类（XXX.class)。</p>
<p>例如：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">int</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      Xxx.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">int</span> setName(String <span class="keyword">name</span>)&#123;</span><br><span class="line">      synchronized(Xxx.<span class="keyword">class</span>)&#123;</span><br><span class="line">            Xxx.<span class="keyword">name</span> = <span class="keyword">name</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即：<br>synchronized主要有两种方法<br>1.1、<strong>synchronized块（对象级）</strong>：<br>    <code>synchronized(this){}</code><br>1.2、<strong>synchronized块（类级别）</strong>：类在堆中存在一个class 对象（注意这里的class是小写），所以所谓的类锁，<strong>本质上还是对一个对象</strong>，在这里也就是class对象进行同步获取。当然体现出来的效果是在类上进行了同步。<br>    <code>synchronized（类名.class）</code><br>2、  <strong>synchronized方法</strong><br><code>public synchronized String setID(){}</code><br><strong>(方法锁和私有锁：都属于对象锁)</strong></p>
<h5 id="四、如果线程不能获得锁会怎么样"><a href="#四、如果线程不能获得锁会怎么样" class="headerlink" title="四、如果线程不能获得锁会怎么样"></a>四、如果线程不能获得锁会怎么样</h5><p>如果线程试图进入同步方法，而其锁已经被占用，则线程在该对象上被阻塞。实质上，线程进入该对象的的一种池中，必须在哪里等待，直到其锁被释放，该线程再次变为可运行或运行为止。</p>
<p>当考虑阻塞时，一定要注意哪个对象正被用于锁定：</p>
<ol>
<li>调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。</li>
<li>调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上。</li>
<li>静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。</li>
<li>对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将永远不会彼此阻塞。</li>
</ol>
<h5 id="五、何时需要同步"><a href="#五、何时需要同步" class="headerlink" title="五、何时需要同步"></a>五、何时需要同步</h5><p>在多个线程同时访问互斥（可交换）数据时，应该同步以保护数据，确保两个线程不会同时修改更改它。</p>
<p>对于非静态字段中可更改的数据，通常使用非静态方法访问。<br>对于静态字段中可更改的数据，通常使用静态方法访问。</p>
<h5 id="六、线程安全类"><a href="#六、线程安全类" class="headerlink" title="六、线程安全类"></a>六、线程安全类</h5><p>当一个类已经很好的同步以保护它的数据时，这个类就称为“线程安全的”。<br>即使是线程安全类，也应该特别小心，因为操作的线程之间仍然不一定安全。</p>
<p>例如：<br>对线程安全的集合进行判断非空和删除所有元素操作的时候，线程一二都查询非空，但是线程一删除元素后线程二再重复执行是错误的。<br>方法：对所有方法增加一个同步锁，这样，当一个线程访问其中一个同步方法时，其他线程只有等待。</p>
<h5 id="七、线程死锁（涉及操作系统）"><a href="#七、线程死锁（涉及操作系统）" class="headerlink" title="七、线程死锁（涉及操作系统）"></a>七、线程死锁（涉及操作系统）</h5><p>所谓死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。<br><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/test/deadlockrisk" target="_blank" rel="noopener">DeadLockRiskTest</a></p>
<p><strong>死锁产生的必要条件：</strong><br>（1）互斥<br>（2）不剥夺<br>（3）请求和保持等待<br>（4）循环等待</p>
<p><strong>避免死锁：</strong></p>
<ul>
<li>加锁顺序（线程按照一定的顺序加锁）</li>
<li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）</li>
<li>死锁检测（LOCK）</li>
</ul>
<p><strong>总结：避免死锁的方式</strong></p>
<ol>
<li>让程序每次至多只能获得一个锁。当然，在多线程环境下，这种情况通常并不现实。</li>
<li>设计时考虑清楚锁的顺序，尽量减少嵌在的加锁交互数量。</li>
<li>既然死锁的产生是两个线程无限等待对方持有的锁，那么只要等待时间有个上限不就好了。当然synchronized不具备这个功能，但是我们可以使用Lock类中的tryLock方法去尝试获取锁，这个方法可以指定一个超时时限，在等待超过该时限之后便会返回一个失败信息。<br>我们可以使用<code>ReentrantLock.tryLock()</code>方法，在一个循环中，如果tryLock()返回失败，那么就释放以及获得的锁，并睡眠一小段时间。这样就打破了死锁的闭环。比如：线程T1持有锁L1并且申请获得锁L2，而线程T2持有锁L2并且申请获得锁L3，而线程T3持有锁L3并且申请获得锁L1。此时如果T3申请锁L1失败，那么T3释放锁L3，并进行睡眠，那么T2就可以获得L3了，然后T2执行完之后释放L2, L3，所以T1也可以获得L2了执行完然后释放锁L1, L2，然后T3睡眠醒来，也可以获得L1, L3了。打破了死锁的闭环。</li>
</ol>
<h5 id="八、线程同步小结"><a href="#八、线程同步小结" class="headerlink" title="八、线程同步小结"></a>八、线程同步小结</h5><ol>
<li><p>线程同步的目的是为了保护多个线程访问一个资源时对资源的破坏。</p>
</li>
<li><p>线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。</p>
</li>
</ol>
<p><strong>注意：方法锁和私有锁都属于对象锁</strong></p>
<ol start="3">
<li><p>对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。<br>（对象锁是在一个类的对象上加的的锁，只有一把，不管有几个方法进行了同步。<br>这些同步方法都共有一把锁，只要一个线程获得了这个对象锁，其他的线程就不能访问该对象的任何一个同步方法。）</p>
</li>
<li><p>对于同步，要时刻清醒在哪个对象上同步，这是关键。</p>
</li>
<li><p>编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。</p>
</li>
<li><p>当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。</p>
</li>
<li><p>死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。</p>
</li>
</ol>
<hr>
<h4 id="Java线程：线程的交互"><a href="#Java线程：线程的交互" class="headerlink" title="Java线程：线程的交互"></a>Java线程：线程的交互</h4><h5 id="线程交互的基础知识"><a href="#线程交互的基础知识" class="headerlink" title="线程交互的基础知识"></a>线程交互的基础知识</h5><h6 id="wait、notify-notifyAll-详解"><a href="#wait、notify-notifyAll-详解" class="headerlink" title="wait、notify/notifyAll 详解"></a>wait、notify/notifyAll 详解</h6><p>void notify() 唤醒在此对象监视器上等待的单个线程。<br>void notifyAll() 唤醒在此对象监视器上等待的所有线程。<br>void wait() 导致当前的线程等待（前提是先获得锁，即在synchronized同步代码块里使用），直到其他线程调用此对象的 notify()方法或 notifyAll()方法。</p>
<p>三个方法都是Object的本地final方法，无法被重写。由于 wait()、notify/notifyAll() 在synchronized 代码块执行，说明当前线程一定是获取了锁的。<br>当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。<br>只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。<br>也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，<strong>尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程让其获得锁。</strong></p>
<p>wait() 需要被try catch包围，以便发生异常中断也可以使wait等待的线程唤醒。    </p>
<h6 id="notify-和-notifyAll的区别"><a href="#notify-和-notifyAll的区别" class="headerlink" title="notify 和 notifyAll的区别"></a>notify 和 notifyAll的区别</h6><p>notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">K</span> &#123;</span><br><span class="line">    <span class="comment">//状态锁</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="keyword">lock</span>;</span><br><span class="line">    <span class="comment">//条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> now,need;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span>(<span class="params"><span class="keyword">int</span> num</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//同步</span></span><br><span class="line">        synchronized (<span class="keyword">lock</span>)&#123;</span><br><span class="line">           <span class="comment">//当前有的不满足需要，进行等待，直到满足条件</span></span><br><span class="line">            <span class="keyword">while</span>(now &lt; need)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//等待阻塞</span></span><br><span class="line">                    <span class="keyword">lock</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"我被唤醒了！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// 做其他的事情</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，只有当前值满足需要值的时候，线程才可以往下执行，所以，必须使用while 循环阻塞。注意，wait() 当被唤醒时候，只是让while循环继续往下走.如果此处用if的话，意味着if继续往下走，会跳出if语句块。</p>
<p><strong>总结：</strong><br>    当等待的事件发生时，需要能够检查notifyAll()通知事件是否已经发生。<br>   通常，解决上面问题的最佳方式是利用某种循环，该循环检查某个条件表达式，只有当正在等待的事情还没有发生的情况下，它才继续等待。</p>
<p><strong>生产者-消费者问题:</strong><br><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/test/producer_consumer" target="_blank" rel="noopener">生产者-消费者问题代码</a></p>
<hr>
<h4 id="Java线程：线程的调度-休眠"><a href="#Java线程：线程的调度-休眠" class="headerlink" title="Java线程：线程的调度-休眠"></a>Java线程：线程的调度-休眠</h4><p>线程休眠的目的是使线程让出CPU的最简单的做法之一，线程休眠时候，会将CPU资源交给其他线程，以便能轮换执行，当休眠一定时间后，线程会苏醒，进入准备状态等待执行。<br>线程休眠的方法是Thread.sleep(long millis)和Thread.sleep(long millis, int nanos)，均为静态方法，哪个线程调用sleep，就休眠哪个线程。</p>
<hr>
<h4 id="Java线程：线程的调度-优先级"><a href="#Java线程：线程的调度-优先级" class="headerlink" title="Java线程：线程的调度-优先级"></a>Java线程：线程的调度-优先级</h4><p>与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。</p>
<p>线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5。</p>
<p>在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">                Thread <span class="built_in">t1</span> = new MyThread1()<span class="comment">;</span></span><br><span class="line">                Thread <span class="built_in">t2</span> = new Thread(new MyRunnable())<span class="comment">;</span></span><br><span class="line">                <span class="built_in">t1</span>.setPriority(<span class="number">10</span>)<span class="comment">; </span></span><br><span class="line">                <span class="built_in">t2</span>.setPriority(<span class="number">1</span>)<span class="comment">; </span></span><br><span class="line">                <span class="built_in">t2</span>.start()<span class="comment">; </span></span><br><span class="line">                <span class="built_in">t1</span>.start()<span class="comment">; </span></span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Java线程：线程的调度-让步"><a href="#Java线程：线程的调度-让步" class="headerlink" title="Java线程：线程的调度-让步"></a>Java线程：线程的调度-让步</h4><p>线程的让步含义就是使当前运行着线程让出CPU资源，但是然给谁不知道，仅仅是让出，线程状态回到可运行状态。</p>
<p>线程的让步使用Thread.yield()方法，yield()为静态方法，功能是暂停当前正在执行的线程对象，并执行其他线程。</p>
<p> 详见：Java线程：线程状态的转换——阻止线程执行</p>
<hr>
<h4 id="Java线程：线程的调度-合并"><a href="#Java线程：线程的调度-合并" class="headerlink" title="Java线程：线程的调度-合并"></a>Java线程：线程的调度-合并</h4><p>线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时可以使用join方法。</p>
<p> 详见：Java线程：线程状态的转换——阻止线程执行<br><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/test/join" target="_blank" rel="noopener">joinTest</a></p>
<hr>
<h4 id="Java线程：线程的调度-守护线程"><a href="#Java线程：线程的调度-守护线程" class="headerlink" title="Java线程：线程的调度-守护线程"></a>Java线程：线程的调度-守护线程</h4><p>只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。<br> Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。</p>
<p>User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。<br><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/daemontest" target="_blank" rel="noopener">daemontest</a></p>
<hr>
<h4 id="Java线程：线程的同步-同步方法、同步块"><a href="#Java线程：线程的同步-同步方法、同步块" class="headerlink" title="Java线程：线程的同步-同步方法、同步块"></a>Java线程：线程的同步-同步方法、同步块</h4><p>详见上文：Java线程：线程的同步与锁</p>
<p>注意：<br>在使用synchronized关键字时候，应该尽可能避免在synchronized方法或synchronized块中使用sleep或者yield方法，因为synchronized程序块占有着对象锁，你休息那么其他的线程只能一边等着你醒来执行完了才能执行。不但严重影响效率，也不合逻辑。<br>同样，在同步程序块内调用yeild方法让出CPU资源也没有意义，因为你占用着锁，其他互斥线程还是无法访问同步程序块。当然与同步程序块无关的线程可以获得更多的执行时间。<br><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/test/synchronize" target="_blank" rel="noopener">同步块</a></p>
<hr>
<h4 id="Java线程：并发协作-死锁"><a href="#Java线程：并发协作-死锁" class="headerlink" title="Java线程：并发协作-死锁"></a>Java线程：并发协作-死锁</h4><p>详见Java线程：线程的同步与锁——线程死锁</p>
<hr>
<h4 id="Java线程：volatile关键字"><a href="#Java线程：volatile关键字" class="headerlink" title="Java线程：volatile关键字"></a>Java线程：volatile关键字</h4><p>Java 语言中的 volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。</p>
<p>解释：<br>Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile 变量的最新值。Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类（例如 “start &lt;=end”）。</p>
<p>出于简易性或可伸缩性的考虑，您可能倾向于使用 volatile 变量而不是锁。当使用 volatile 变量而非锁时，某些习惯用法（idiom）更加易于编码和阅读。此外，volatile 变量不会像锁那样造成线程阻塞，因此也很少造成可伸缩性问题。在某些情况下，如果读操作远远大于写操作，volatile 变量还可以提供优于锁的性能优势。</p>
<p><strong>volatile、synchronized</strong><br>volatile 功能，声明了volatile的变量，进行写操作的时候，jvm会向处理器发送一条Lock的前缀指令，会把这个变量所在缓存行的数据写回到系统内存。<br>在多处理器的情况下，保证各个处理器缓存一致性的特点，会实现缓存一致性协议。改变了值的volatile变量，在其他行程被指为失效状态其他线程要使用这个变量，需要重新到驻村里面去取。</p>
<p><strong>synchronized：可重入锁、互斥性、可见性<br>volatile 可以做到原子性，可见性，不能做到复合操作的原子性</strong></p>
<p>比如： volatile int i;<br>i++ 读取i的值，给i加1，把新的值赋值给i，这个i++操作在多线程环境下是无法保证原子性的</p>
<p>synchronized后面锁定的对象，可以是一个类对象，也可以是一个成员变量。<br>第一个线程进来调用monitorener 和monitorexit实现，获取对象的监视器，释放对象监视器<br>后续进程过来，如果monitor还没有释放，那么他获取不到这个对象的monitor，会放到一个对列里面：synthronizedQueue。 等到对象的锁释放了，通知synthronizedQueue出队列，获取那个monitor。</p>
<p><strong>volatile 的限制——只有在状态真正独立于程序内其他内容时才能使用 volatile</strong></p>
<hr>
<h4 id="Java线程：新特征-线程池"><a href="#Java线程：新特征-线程池" class="headerlink" title="Java线程：新特征-线程池"></a>Java线程：新特征-线程池</h4><h5 id="一、固定大小的线程池"><a href="#一、固定大小的线程池" class="headerlink" title="一、固定大小的线程池"></a>一、固定大小的线程池</h5><p>//创建一个可重用固定线程数的线程池<br><code>ExecutorService pool = Executors.newFixedThreadPool(2);</code></p>
<h5 id="二、单任务线程池"><a href="#二、单任务线程池" class="headerlink" title="二、单任务线程池"></a>二、单任务线程池</h5><p>//创建一个使用单个 worker线程的 Executor，以无界队列方式来运行该线程。<br><code>ExecutorService pool = Executors.newSingleThreadExecutor();</code></p>
<h5 id="三、可变尺寸的线程池"><a href="#三、可变尺寸的线程池" class="headerlink" title="三、可变尺寸的线程池"></a>三、可变尺寸的线程池</h5><p>//创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。<br><code>ExecutorService pool = Executors.newCachedThreadPool();</code></p>
<h5 id="四、延迟连接池"><a href="#四、延迟连接池" class="headerlink" title="四、延迟连接池"></a>四、延迟连接池</h5><p>//创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。<br><code>ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);</code><br>//使用延迟执行风格的方法<br><code>pool.schedule(t4, 10, TimeUnit.MILLISECONDS);</code></p>
<h5 id="五、单任务延迟连接池"><a href="#五、单任务延迟连接池" class="headerlink" title="五、单任务延迟连接池"></a>五、单任务延迟连接池</h5><p>//创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。<br><code>ScheduledExecutorService pool = Executors.newSingleThreadScheduledExecutor();</code></p>
<h5 id="六、自定义线程池"><a href="#六、自定义线程池" class="headerlink" title="六、自定义线程池"></a>六、自定义线程池</h5><p>//创建等待队列<br><code>BlockingQueue&lt;Runnable&gt; bqueue = new ArrayBlockingQueue&lt;Runnable&gt;(20);</code><br>//创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。<br><code>ThreadPoolExecutor pool = new ThreadPoolExecutor(2,3,2,TimeUnit.MILLISECONDS,bqueue);</code></p>
<h5 id="七、代码参考"><a href="#七、代码参考" class="headerlink" title="七、代码参考"></a>七、代码参考</h5><p><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/threadpool" target="_blank" rel="noopener">ThreadPool</a><br><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/test/threadpool" target="_blank" rel="noopener">DIYThreadPool</a></p>
<hr>
<h4 id="Java线程：新特征-锁"><a href="#Java线程：新特征-锁" class="headerlink" title="Java线程：新特征-锁"></a>Java线程：新特征-锁</h4><p>在Java5中，专门提供了锁对象，利用锁可以方便的实现资源的封锁，用来控制对竞争资源并发访问的控制，这些内容主要集中在java.util.concurrent.locks包下面，里面有三个重要的接口Condition、Lock、ReadWriteLock。</p>
<p><strong>Condition：</strong><br>Condition将Object监视器方法（wait、notify和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意Lock实现组合使用，为每个对象提供多个等待 set（wait-set）。</p>
<p><strong>Lock：</strong><br>Lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。</p>
<p><strong>ReadWriteLock：</strong><br>ReadWriteLock维护了一对相关的锁定，一个用于只读操作，另一个用于写入操作。<br>ReentrantReadWriteLock：把它理解成一个数据库的事务锁（拆分成读锁和写锁、写锁之间互斥，读锁不互斥、要获取写锁必须除当前线程外不能存在其他的读锁）。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="literal">false</span>);</span><br><span class="line">sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br></pre></td></tr></table></figure>

<p>注意：lock必须lock.unlock()释放，否则如果受保护的代码抛出异常，锁就可能永远得不到释放。</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lock</span> <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock()<span class="comment">;</span></span><br><span class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>()<span class="comment">;</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="comment">// update object state</span></span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">  <span class="keyword">lock</span>.unlock()<span class="comment">; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于ReentrantLock：</strong></p>
<p><a href="https://blog.csdn.net/fw0124/article/details/6672522" target="_blank" rel="noopener">Java中的ReentrantLock和synchronized两种锁定机制的对比</a><br><a href="https://blog.csdn.net/yanyan19880509/article/details/52345422" target="_blank" rel="noopener">轻松学习java可重入锁(ReentrantLock)的实现原理</a></p>
<p>在上文中提到了Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，在一定程度上提高了程序的执行效率。<br>Java中读写锁有个接口<code>java.util.concurrent.locks.ReadWriteLock</code>，也有具体的实现</p>
<p><strong>在实际开发中，最好能用读写锁的情况下使用读写锁，而不要用普通锁，以求更好的性能。</strong></p>
<p><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/lock" target="_blank" rel="noopener">锁相关代码</a></p>
<hr>
<h4 id="Java线程：新特征-信号量"><a href="#Java线程：新特征-信号量" class="headerlink" title="Java线程：新特征-信号量"></a>Java线程：新特征-信号量</h4><p>Java的信号量实际上是一个功能完毕的计数器，对控制一定资源的消费与回收有着很重要的意义，信号量常常用于多线程的代码中，并能监控有多少数目的线程等待获取资源，并且通过信号量可以得知可用资源的数目等等，这里总是在强调“数目”二字，但不能指出来有哪些在等待，哪些资源可用。</p>
<p>观点：信号量类如果能返回数目，还能知道哪些对象在等待，哪些资源可使用，就非常完美了，仅仅拿到这些概括性的数字，对精确控制意义不是很大。目前还没想到更好的用法。</p>
<p><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/semaphore" target="_blank" rel="noopener">信号量代码</a></p>
<hr>
<h4 id="Java线程：新特征-阻塞队列"><a href="#Java线程：新特征-阻塞队列" class="headerlink" title="Java线程：新特征-阻塞队列"></a>Java线程：新特征-阻塞队列</h4><p>阻塞队列是Java5线程新特征中的内容，Java定义了阻塞队列的接口<code>java.util.concurrent.BlockingQueue</code>，阻塞队列的概念是，一个指定长度的队列，如果队列满了，添加新元素的操作会被阻塞等待，直到有空位为止。同样，当队列为空时候，请求队列元素的操作同样会阻塞等待，直到有可用元素为止。<br>有了这样的功能，就为多线程的排队等候的模型实现开辟了便捷通道，非常有用。<br>java.util.concurrent.BlockingQueue继承了java.util.Queue接口，可以参看API文档。</p>
<p><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/blocking" target="_blank" rel="noopener">BlockingQueue代码</a></p>
<p><strong>BlockingQueue核心方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定元素设置到队列中，如果设置成功返回true, 否则返回false。如果是往限定了长度的队列中设置值，推荐使用offer()方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定的元素设置到队列中，如果设置成功返回true, 否则返回false. e的值不能为空，否则抛出空指针异常。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将元素设置到队列中，如果队列中没有多余的空间，该方法会一直阻塞，直到队列中有多余的空间。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定元素在给定的时间内设置到队列中，如果设置成功返回true, 否则返回false.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中获取值，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该方法取得了该值。</span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在给定的时间里，从队列中获取值，时间到了直接调用普通的poll方法，为null则直接返回null。</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列中剩余的空间。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中移除指定的值。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列中是否拥有该值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将队列中值，全部移除，并发设置到给定的集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定最多数量限制将队列中值，全部移除，并发设置到给定的集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员详解：<br><strong>ArrayBlockingQueue</strong><br>　　基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。<br>　　ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>
<p><strong>LinkedBlockingQueue</strong><br>　　基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</p>
<p><strong>DelayQueue</strong><br>　　DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<br>使用场景：<br>　　DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。</p>
<p><strong>PriorityBlockingQueue</strong><br>　　基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p>
<p><strong>SynchronousQueue</strong><br>　　一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。<br>　　声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:<br>　　如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；<br>　　但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>
<p><a href="https://www.jianshu.com/p/6ba87c7508e4" target="_blank" rel="noopener">参考链接:https://www.jianshu.com/p/6ba87c7508e4</a></p>
<p>阻塞队列还有更多实现类，用来满足各种复杂的需求：ArrayBlockingQueue, DelayQueue, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue，具体的API差别也很小。</p>
<hr>
<h4 id="Java线程：新特征-阻塞栈"><a href="#Java线程：新特征-阻塞栈" class="headerlink" title="Java线程：新特征-阻塞栈"></a>Java线程：新特征-阻塞栈</h4><p>对于阻塞栈，与阻塞队列相似。不同点在于栈是“后入先出”的结构，每次操作的是栈顶，而队列是“先进先出”的结构，每次操作的是队列头。<br>这里要特别说明一点的是，阻塞栈是Java6的新特征。<br><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/blocking" target="_blank" rel="noopener">BlockingDeque代码</a></p>
<hr>
<h4 id="Java线程：新特征-条件变量"><a href="#Java线程：新特征-条件变量" class="headerlink" title="Java线程：新特征-条件变量"></a>Java线程：新特征-条件变量</h4><p>条件变量是Java5线程中很重要的一个概念，顾名思义，条件变量就是表示条件的一种变量。但是必须说明，这里的条件是没有实际含义的，仅仅是个标记而已，并且条件的含义往往通过代码来赋予其含义。这里的条件和普通意义上的条件表达式有着天壤之别。他不是自然语言中的条件概念，而是程序控制的一种手段。</p>
<p>条件变量都实现了java.util.concurrent.locks.Condition接口，条件变量的实例化是通过一个Lock对象上调用newCondition()方法来获取的，这样，条件就和一个锁对象绑定起来了。因此，Java中的条件变量只能和锁配合使用，来控制并发程序访问竞争资源的安全。<br>条件变量的出现是为了更精细控制线程等待与唤醒，在Java5之前，线程的等待与唤醒依靠的是Object对象的wait()和notify()/notifyAll()方法，这样的处理不够精细。<br>而在Java5中，一个锁可以有多个条件，每个条件上可以有多个线程等待，通过调用await()方法，可以让线程在该条件下等待。当调用signalAll()方法，又可以唤醒该条件下的等待的线程。<br><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/condition" target="_blank" rel="noopener">条件变方法</a><br><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/uncondition" target="_blank" rel="noopener">非条件变量方法</a></p>
<hr>
<h4 id="Java线程：新特征-原子量"><a href="#Java线程：新特征-原子量" class="headerlink" title="Java线程：新特征-原子量"></a>Java线程：新特征-原子量</h4><p>所谓的原子量即操作变量的操作是“原子的”，该操作不可再分，因此是线程安全的。<br>为何要使用原子变量呢，原因是多个线程对单个变量操作也会引起一些问题。在Java5之前，可以通过volatile、synchronized关键字来解决并发访问的安全问题，但这样太麻烦。<br>Java5之后，专门提供了用来进行单变量多线程并发安全访问的工具包<code>java.util.concurrent.atomic</code>，其中的类也很简单。<br>原子量虽然可以保证单个变量在某一个操作过程的安全，但无法保证你整个代码块，或者整个程序的安全性。因此，通常还应该使用锁等同步机制来控制整个程序的安全性。</p>
<p><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/atomic" target="_blank" rel="noopener">atomicTest</a></p>
<p>原子仅仅是保证变量操作的原子性，但整个程序还需要考虑线程安全的。</p>
<hr>
<h4 id="Java线程：新特征-障碍器"><a href="#Java线程：新特征-障碍器" class="headerlink" title="Java线程：新特征-障碍器"></a>Java线程：新特征-障碍器</h4><p>Java5中，添加了障碍器类，为了适应一种新的设计需求，比如一个大型的任务，常常需要分配好多子任务去执行，只有当所有子任务都执行完成时候，才能执行主任务，这时候，就可以选择障碍器了。<br>障碍器是多线程并发控制的一种手段。</p>
<p>CyclicBarrier栅栏类似于闭锁，它能阻塞一组线程直到某个事件的发生。栅栏与闭锁的关键区别在于，<strong>所有的线程必须同时到达栅栏位置，才能继续执行</strong>。闭锁用于等待事件，而栅栏用于等待其他线程。<br>CyclicBarrier可以使一定数量的线程反复地在栅栏位置处汇集。当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达栅栏位置，那么栅栏将打开，此时所有的线程都将被释放，而栅栏将被重置以便下次使用。</p>
<p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程使用await()方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。<br>CyclicBarrier的另一个构造函数CyclicBarrier(int parties, Runnable barrierAction)，用于线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。<br>调用await方法的线程告诉CyclicBarrier自己已经到达同步点，然后当前线程被阻塞。直到parties个参与线程调用了await方法，CyclicBarrier同样提供带超时时间的await和不带超时时间的await方法。<br><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/cyclicbarrier" target="_blank" rel="noopener">cyclicbarrier代码</a></p>
<hr>
<h4 id="面试笔试题（更新中）"><a href="#面试笔试题（更新中）" class="headerlink" title="面试笔试题（更新中）"></a>面试笔试题（更新中）</h4><p><a href="https://github.com/TangSong99/Thread_Demo/tree/master/out/production/threaddemo/facetest/test1" target="_blank" rel="noopener">面试笔试题1</a></p>

    </div>

    
    
    
        
      
        <div id="reward-container">
  <div>请我喝杯快乐水叭QAQ.</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.png" alt="唐宋丶 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>唐宋丶</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://TangSong99.github.io/2019/11/18/Java线程详解/" title="Java线程详解">http://TangSong99.github.io/2019/11/18/Java线程详解/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-Hans" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

	  <div>
	    
	    <div>
<script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=&amp;pophcol=2&amp;lang=zh"></script><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/bshareC0.js"></script>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">已经到底啦(〃'▽'〃)</div>
        <div class="bshare-custom"><div class="bsPromo bsPromo2"></div><a title="分享到QQ空间" class="bshare-qzone"></a><a title="分享到QQ好友" class="bshare-qqim" href="javascript:void(0);"></a><a title="分享到微信" class="bshare-weixin" href="javascript:void(0);"></a><a title="分享到新浪微博" class="bshare-sinaminiblog" href="javascript:void(0);"></a><a title="分享到Facebook" class="bshare-facebook" href="javascript:void(0);"></a><a title="分享到Twitter" class="bshare-twitter" href="javascript:void(0);"></a><a title="更多平台" class="bshare-more bshare-more-icon more-style-addthis"></a></div>
    
</div>

	    
	  </div>
	  
      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/10/11/什么是Java内部类/" rel="next" title="什么是Java内部类?">
                  <i class="fa fa-chevron-left"></i> 什么是Java内部类?
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    
  <div class="comments" id="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NjIxMC8yMjcyMQ=="></div>
  </div>
  
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/tx.jpg"
      alt="唐宋丶">
  <p class="site-author-name" itemprop="name">唐宋丶</p>
  <div class="site-description motion-element" itemprop="description">在努力在生活在前进.</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/TangSong99" title="GitHub &rarr; https://github.com/TangSong99" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://user.qzone.qq.com/348958520" title="QZone &rarr; https://user.qzone.qq.com/348958520" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>QZone</a>
      </span>
    
  </div>
  <div class="cc-license motion-element" itemprop="license">
    
  
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-Hans" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element links-of-blogroll-block">
    <div class="links-of-blogroll-title">
      <i class="fa  fa-fw fa-link"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.bilibili.com" title="https://www.bilibili.com" rel="noopener" target="_blank">哔哩哔哩</a>
        </li>
      
    </ul>
  </div>


        </div>
      </div>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=200 height=86 src="//music.163.com/outchain/player?type=2&id=32408263&auto=1&height=66"></iframe>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
			
            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程概述"><span class="nav-number">1.</span> <span class="nav-text">线程概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：创建与启动"><span class="nav-number">2.</span> <span class="nav-text">Java线程：创建与启动</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一、定义线程"><span class="nav-number">2.1.</span> <span class="nav-text">一、定义线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二、实例化线程"><span class="nav-number">2.2.</span> <span class="nav-text">二、实例化线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三、启动线程"><span class="nav-number">2.3.</span> <span class="nav-text">三、启动线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#四、例子"><span class="nav-number">2.4.</span> <span class="nav-text">四、例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#五、一些常见问题"><span class="nav-number">2.5.</span> <span class="nav-text">五、一些常见问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：线程栈模型与线程的变量"><span class="nav-number">3.</span> <span class="nav-text">Java线程：线程栈模型与线程的变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：线程状态的转换"><span class="nav-number">4.</span> <span class="nav-text">Java线程：线程状态的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一、线程状态"><span class="nav-number">4.1.</span> <span class="nav-text">一、线程状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二、阻止线程执行"><span class="nav-number">4.2.</span> <span class="nav-text">二、阻止线程执行</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、睡眠sleep"><span class="nav-number">4.2.1.</span> <span class="nav-text">1、睡眠sleep()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、线程的优先级和线程让步yield"><span class="nav-number">4.2.2.</span> <span class="nav-text">2、线程的优先级和线程让步yield()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、Thread-yield-方法"><span class="nav-number">4.2.3.</span> <span class="nav-text">3、Thread.yield()方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4、join-方法"><span class="nav-number">4.2.4.</span> <span class="nav-text">4、join()方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小结"><span class="nav-number">4.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：线程的同步与锁"><span class="nav-number">5.</span> <span class="nav-text">Java线程：线程的同步与锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一、同步问题提出"><span class="nav-number">5.1.</span> <span class="nav-text">一、同步问题提出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二、同步和锁定"><span class="nav-number">5.2.</span> <span class="nav-text">二、同步和锁定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三、静态方法同步"><span class="nav-number">5.3.</span> <span class="nav-text">三、静态方法同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#四、如果线程不能获得锁会怎么样"><span class="nav-number">5.4.</span> <span class="nav-text">四、如果线程不能获得锁会怎么样</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#五、何时需要同步"><span class="nav-number">5.5.</span> <span class="nav-text">五、何时需要同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#六、线程安全类"><span class="nav-number">5.6.</span> <span class="nav-text">六、线程安全类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#七、线程死锁（涉及操作系统）"><span class="nav-number">5.7.</span> <span class="nav-text">七、线程死锁（涉及操作系统）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#八、线程同步小结"><span class="nav-number">5.8.</span> <span class="nav-text">八、线程同步小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：线程的交互"><span class="nav-number">6.</span> <span class="nav-text">Java线程：线程的交互</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#线程交互的基础知识"><span class="nav-number">6.1.</span> <span class="nav-text">线程交互的基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#wait、notify-notifyAll-详解"><span class="nav-number">6.1.1.</span> <span class="nav-text">wait、notify/notifyAll 详解</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#notify-和-notifyAll的区别"><span class="nav-number">6.1.2.</span> <span class="nav-text">notify 和 notifyAll的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：线程的调度-休眠"><span class="nav-number">7.</span> <span class="nav-text">Java线程：线程的调度-休眠</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：线程的调度-优先级"><span class="nav-number">8.</span> <span class="nav-text">Java线程：线程的调度-优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：线程的调度-让步"><span class="nav-number">9.</span> <span class="nav-text">Java线程：线程的调度-让步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：线程的调度-合并"><span class="nav-number">10.</span> <span class="nav-text">Java线程：线程的调度-合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：线程的调度-守护线程"><span class="nav-number">11.</span> <span class="nav-text">Java线程：线程的调度-守护线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：线程的同步-同步方法、同步块"><span class="nav-number">12.</span> <span class="nav-text">Java线程：线程的同步-同步方法、同步块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：并发协作-死锁"><span class="nav-number">13.</span> <span class="nav-text">Java线程：并发协作-死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：volatile关键字"><span class="nav-number">14.</span> <span class="nav-text">Java线程：volatile关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：新特征-线程池"><span class="nav-number">15.</span> <span class="nav-text">Java线程：新特征-线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一、固定大小的线程池"><span class="nav-number">15.1.</span> <span class="nav-text">一、固定大小的线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二、单任务线程池"><span class="nav-number">15.2.</span> <span class="nav-text">二、单任务线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三、可变尺寸的线程池"><span class="nav-number">15.3.</span> <span class="nav-text">三、可变尺寸的线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#四、延迟连接池"><span class="nav-number">15.4.</span> <span class="nav-text">四、延迟连接池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#五、单任务延迟连接池"><span class="nav-number">15.5.</span> <span class="nav-text">五、单任务延迟连接池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#六、自定义线程池"><span class="nav-number">15.6.</span> <span class="nav-text">六、自定义线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#七、代码参考"><span class="nav-number">15.7.</span> <span class="nav-text">七、代码参考</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：新特征-锁"><span class="nav-number">16.</span> <span class="nav-text">Java线程：新特征-锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：新特征-信号量"><span class="nav-number">17.</span> <span class="nav-text">Java线程：新特征-信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：新特征-阻塞队列"><span class="nav-number">18.</span> <span class="nav-text">Java线程：新特征-阻塞队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：新特征-阻塞栈"><span class="nav-number">19.</span> <span class="nav-text">Java线程：新特征-阻塞栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：新特征-条件变量"><span class="nav-number">20.</span> <span class="nav-text">Java线程：新特征-条件变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：新特征-原子量"><span class="nav-number">21.</span> <span class="nav-text">Java线程：新特征-原子量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程：新特征-障碍器"><span class="nav-number">22.</span> <span class="nav-text">Java线程：新特征-障碍器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面试笔试题（更新中）"><span class="nav-number">23.</span> <span class="nav-text">面试笔试题（更新中）</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
      
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">唐宋丶</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/pisces.js?v=7.3.0"></script>

<script src="/js/next-boot.js?v=7.3.0"></script>



  













  <script src="/js/local-search.js?v=7.3.0"></script>














  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script><script src="/js/post-details.js?v=7.3.0"></script>


<script>
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>

  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/clicklove.js"></script>
</body>
</html>
